
// nuc.hh
#include "nuc.h"

template <typename T, typename LatStru>
Nuc2D<T, LatStru>::Nuc2D(GandinConverter<T> &convca, LBManager2D<T> &lbm,
                         CAGField2D<T> &ca)
    : ConvCA(convca), CA(ca), Geo(CA.Geo), message(4), rd() {
  DT_Mean_Bulk = ConvCA.Lattice_DT_Mean_Bulk;
  DT_Std_Bulk = ConvCA.Lattice_DT_Std_Bulk;
  DT_Mean_Surf = ConvCA.Lattice_DT_Mean_Surf;
  DT_Std_Surf = ConvCA.Lattice_DT_Std_Surf;
  NucDens_Bulk = ConvCA.Lattice_NucDens_Bulk;
  NucDens_Surf = ConvCA.Lattice_NucDens_Surf;

  int max_nucs = NucDens_Surf * ((Geo.getNi() + Geo.getNj() - 4) * 2 - 4) +
                 NucDens_Bulk * (Geo.getNi() - 4) * (Geo.getNj() - 4);
#ifdef _NUC_P
  OMP_helper::Setup_Thread_Vec<gcell2D<T>>(Nucs_Th, max_nucs);
  OMP_helper::Setup_Thread_Vec<int>(PreNucs_Th, max_nucs);
  OMP_helper::Setup_Thread_Vec<T>(DTCrit_Th, max_nucs);
#else
  PreNucs.reserve(max_nucs);
  DTCrit.reserve(max_nucs);
  gen = std::mt19937(rd());
#endif
}

template <typename T, typename LatStru>
Nuc2D<T, LatStru>::~Nuc2D() {
  // #ifdef _NUC_P
  //   delete[] visited_ato;
  // #else
  //   delete[] visited;
  // #endif
}

// Nucleation
template <typename T, typename LatStru>
void Nuc2D<T, LatStru>::Nucleation(std::vector<gcell2D<T>> &Nucs,
                                   LBManager2D<T> &LBM) {
#ifdef _NUC_P
  Nucs.clear();
  // do not divide Nucs to Nucs_Th
  // OMP_helper::Divide<int>(PreNucs, PreNucs_Th);
  // OMP_helper::Divide<T>(DTCrit, DTCrit_Th);
  OMP_helper::LoadBalancer(PreNucs_Th);
  OMP_helper::LoadBalancer(DTCrit_Th);
  int thn = 0;
#pragma omp parallel for private(thn) num_threads(Thread_Num)
  for (int i = 0; i < PreNucs_Th.size(); i++) {
    thn = omp_get_thread_num();
    nucleation_s(Nucs_Th[thn], LBM, PreNucs_Th[thn], DTCrit_Th[thn]);
  }
  OMP_helper::Merge<gcell2D<T>>(Nucs, Nucs_Th);
#else
  nucleation_s(Nucs, LBM, PreNucs, DTCrit);
#endif
}

// single thread version of Nucleation
template <typename T, typename LatStru>
void Nuc2D<T, LatStru>::nucleation_s(std::vector<gcell2D<T>> &nucs,
                                     LBManager2D<T> &lbm,
                                     std::vector<int> &prenucs,
                                     std::vector<T> &dt_critic) {
  int Id = 0;
  nucs.clear();
  for (int i = 0; i < prenucs.size(); i++) {
    Id = prenucs[i];
    if (CA.State[Id] == 0) {
      if (lbm.getlbmTH()->getPoprho(Id) >
          ConvCA.get_LatTliq(lbm.getlbmSO()->getPoprho(Id)) - dt_critic[i]) {
        CA.State[Id] = 1;
        CA.Orine[Id] = (std::rand() % 90) * M_PI / T(180);
        Geo.getVoxel(Id).getFlag() = 1;
        nucs.emplace_back(Id, Geo.getVoxel(Id)[0], Geo.getVoxel(Id)[1]);
      }
    }
  }
}

template <typename T, typename LatStru>
void Nuc2D<T, LatStru>::Single_Nucleation(int latx, int laty, T orine,
                                          std::vector<gcell2D<T>> &nucs) {
  int Id = Index2D::GetId(latx, laty, Geo.getNi());
  CA.State[Id] = 1;
  CA.Orine[Id] = orine;
  Geo.getVoxel(Id).getFlag() = 1;
  nucs.emplace_back(Id, Geo.getVoxel(Id)[0], Geo.getVoxel(Id)[1]);
}

// create PreNucs on remain cells and critical undercooling
template <typename T, typename LatStru>
void Nuc2D<T, LatStru>::Create_PreNucs(std::vector<int> &Bulks,
                                       std::vector<int> &Surfs) {
  // Set up normal distribution (C++11) and random number generator,
  // use random_device to generate seed, avoid same series of random numbers
  // critical undercooling of PreNucs is generated by normal distribution
  std::default_random_engine Engine;
  std::normal_distribution<T> Gauss_Bulk(DT_Mean_Bulk, DT_Std_Bulk);
  std::normal_distribution<T> Gauss_Surf(DT_Mean_Surf, DT_Std_Surf);

  int bulks = Bulks.size();
  int surfs = Surfs.size();

  /*Bulk cell*/
  if (bulks == 0) {
    msg_out(0, "All Bulk Cells are Solified");
  } else {
    int Bulk_Sites = round(NucDens_Bulk * bulks + 0.5);
    // #pragma omp parallel for private(Id)
    if (Bulk_Sites == 0) {
      msg_out(1, "No NucSite in Bulk!");
      Accum_Bulk_Sites += NucDens_Bulk * bulks;
      if (Accum_Bulk_Sites >= 1) {
        Accum_Bulk_Sites = 0;
        create_s(PreNucs, DTCrit, Bulks, 1, Engine, Gauss_Bulk);
      }
    } else {
// parallelize may not be efficient
#ifdef _NUC_P
      int thn = 0;
      std::vector<int> bulks_Th = OMP_helper::Divide_Num(Bulk_Sites);
#pragma omp parallel for private(thn) num_threads(Thread_Num)
      for (int i = 0; i < bulks_Th.size(); i++) {
        thn = omp_get_thread_num();
        create_s(PreNucs_Th[thn], DTCrit_Th[thn], Bulks, bulks_Th[i], Engine,
                 Gauss_Bulk);
        // no need to merge for now
        // xxx_Th will be used in Nucleation
      }
#else
      create_s(PreNucs, DTCrit, Bulks, Bulk_Sites, Engine, Gauss_Bulk);
#endif
    }
  }
  /*surface cell*/
  if (surfs == 0) {
    msg_out(2, "All Surface Cells are Solified");
  } else {
    int Surf_Sites = round(NucDens_Surf * surfs + 0.5);
    if (Surf_Sites == 0) {
      msg_out(3, "No NucSite in Surface!");
      Accum_Surf_Sites += NucDens_Surf * surfs;
      if (Accum_Surf_Sites >= 1) {
        Accum_Surf_Sites = 0;
        create_s(PreNucs, DTCrit, Surfs, Surf_Sites, Engine, Gauss_Surf);
      }
    } else {
#ifdef _NUC_P
      int thn = 0;
      std::vector<int> surfs_Th = OMP_helper::Divide_Num(Surf_Sites);
#pragma omp parallel for private(thn) num_threads(Thread_Num)
      for (int i = 0; i < surfs_Th.size(); i++) {
        thn = omp_get_thread_num();
        create_s(PreNucs_Th[thn], DTCrit_Th[thn], Surfs, surfs_Th[i], Engine,
                 Gauss_Surf);
        // no need to merge for now
        // xxx_Th will be used in Nucleation
      }
#else
      create_s(PreNucs, DTCrit, Surfs, Surf_Sites, Engine, Gauss_Surf);
#endif
    }
  }
}

template <typename T, typename LatStru>
void Nuc2D<T, LatStru>::create_s(std::vector<int> &prenucs,
                                 std::vector<T> &dt_critic,
                                 std::vector<int> &remains, int count,
                                 std::default_random_engine &engine,
                                 std::normal_distribution<T> &gauss) {
#ifdef _NUC_P
  std::mt19937 gen = std::mt19937(rd());
#endif
  // clear PreNucs or PreNucs_Th[i]
  prenucs.clear();
  // clear DTCrit or DTCrit_Th[i]
  dt_critic.clear();
  // cell id and index in remains
  // use index as index in visited, avoid repeated cell id
  // it is recommended to not use id as index in visited
  // cause id may be very large, causing visited very large
  int id = 0;
  int index = 0;
  // avoid repeated cell id
  int remains_size = remains.size();
  bool *visited = new bool[remains_size];
  std::fill_n(visited, remains_size, false);
  // ATTENTION! Maximum value can be returned by rand() is 32,767
  // use std::uniform_int_distribution instead
  std::uniform_int_distribution<> dis(0, remains_size - 1);
  for (int i = 0; i < count; i++) {
    index = dis(gen);
    id = remains[index];
    if (!visited[index]) {
      visited[index] = true;
      T dT_critic = gauss(engine);
      if (dT_critic < 0) dT_critic = 0;
      dt_critic.emplace_back(dT_critic);
      prenucs.emplace_back(id);
    }
  }
  delete[] visited;
}

// LEGACY
// template <typename T>
// void Nuc2D<T>::Create_PreNucs(std::vector<int> &Bulks,
//                               std::vector<int> &Surfs) {
//   // Set up normal distribution (C++11) and random number generator,
//   // use random_device to generate seed, avoid same series of random numbers
//   // critical undercooling of PreNucs is generated by normal distribution
//   std::default_random_engine Random_Engine;
//   std::normal_distribution<T> Gauss_Bulk(DT_Mean_Bulk, DT_Std_Bulk);
//   std::normal_distribution<T> Gauss_Surf(DT_Mean_Surf, DT_Std_Surf);

//   PreNucs.clear();
//   DTCrit.clear();

// #ifdef _CREATE_PRENUC_P
//   std::fill_n(visited_ato, N, ATOMIC_FLAG_INIT);
// #else
//   std::fill_n(visited, N, false);
// #endif

//   int Bulks_Num = Bulks.size();
//   int Surfs_Num = Surfs.size();
//   int Id = 0;

//   /*Bulk cell*/
//   if (Bulks_Num == 0) {
//     msg_out(0, "All Bulk Cells are Solified");
//   } else {
//     int Bulk_Sites = round(NucDens_Bulk * Bulks_Num + 0.5);
//     // #pragma omp parallel for private(Id)
//     if (Bulk_Sites == 0) {
//       msg_out(1, "No NucSite in Bulk!");
//       Accumulated_NucCount_Bulk += NucDens_Bulk * Bulks_Num;
//       if (Accumulated_NucCount_Bulk >= 1) {
//         Bulk_Sites = 1;
//         Accumulated_NucCount_Bulk = 0;
//       }
//     }
// // parallelize may not be efficient cause Bulk_Sites may be small in a
// // single step
// #ifdef _CREATE_PRENUC_P
//     thread_local std::mt19937 gen_thread(gen());
//     // ATTENTION! Maximum value can be returned by rand() is 32,767
//     std::uniform_int_distribution<> dis(0, Bulks_Num - 1);
// #pragma omp parallel for private(Id)
//     for (int i = 0; i < Bulk_Sites; i++) {
//       Id = Bulks[dis(gen_thread)];
//       // test_and_set is called on object flags[Id],
//       // sets the flag to true andn returns its previous value
//       // if the previous value is false, then the cell is not visited
//       // if the previous value is true, then the cell has been visited
//       if (!visited_ato[Id].test_and_set(std::memory_order_acquire)) {
//         T dT_critic = Gauss_Bulk(Random_Engine);
//         if (dT_critic < 0) dT_critic = 0;
//         DT_Thread[omp_get_thread_num()].emplace_back(dT_critic);
//         PreNucs_Thread[omp_get_thread_num()].emplace_back(Id);  // Cell Id
//       }
//     }
// #else
//     // serialised version
//     std::uniform_int_distribution<> dis(0, Bulks_Num - 1);
//     for (int i = 0; i < Bulk_Sites; i++) {
//       Id = Bulks[dis(gen)];
//       /*create critical undercooling */
//       if (!visited[Id]) {
//         visited[Id] = true;
//         T dT_critic = Gauss_Bulk(Random_Engine);
//         if (dT_critic < 0) dT_critic = 0;
//         DTCrit.emplace_back(dT_critic);
//         PreNucs.emplace_back(Id);
//       }
//     }
// #endif
//   }

//   /*surface cell*/
//   if (Surfs_Num == 0) {
//     msg_out(2, "All Surface Cells are Solified");
//   } else {
//     int Surf_Sites = round(NucDens_Surf * Surfs_Num + 0.5);
//     if (Surf_Sites == 0) {
//       msg_out(3, "No NucSite in Surface!");
//       Accumulated_NucCount_Surf += NucDens_Surf * Surfs_Num;
//       if (Accumulated_NucCount_Surf >= 1) {
//         Surf_Sites = 1;
//         Accumulated_NucCount_Surf = 0;
//       }
//     }
//     // serialised
//     std::uniform_int_distribution<> dis(0, Surfs_Num - 1);
//     for (int i = 0; i < Surf_Sites; i++) {
//       Id = Surfs[dis(gen)];
//       if (!visited[Id]) {
//         visited[Id] = true;
//         T dT_critic = Gauss_Surf(Random_Engine);
//         if (dT_critic < 0) dT_critic = 0;
//         DTCrit.emplace_back(dT_critic);
//         PreNucs.emplace_back(Id);  // Cell Id
//       }
//     }
//   }

// #ifdef _CREATE_PRENUC_P
//   // merge vectors of all threads to one vector
//   OMP_helper::Merge_and_Clear<int>(PreNucs, PreNucs_Thread);
//   OMP_helper::Merge_and_Clear<T>(DTCrit, DT_Thread);
// #endif
// }