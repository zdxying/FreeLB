


ATOMIC: 4096
ATOMICFLAG: 4096
SERIAL: 4096
ATOMIC: 33856
ATOMICFLAG: 33856
SERIAL: 33856
ATOMIC: 364816
ATOMICFLAG: 364816
SERIAL: 364816
ATOMIC: 3254416
ATOMICFLAG: 3254416
SERIAL: 3254416



    for (int i = 0; i < _Mesh._Cells.size(); ++i) {
      id = _Mesh._Cells[i];
      if (_Mesh._Flag[id] == 1) {
        // get neighbours
        for (int j = 0; j < 8; j++) {
          idn = id + _Mesh._Nbr[j];
            if (!_Visited[idn]) {
              Cells.emplace_back(idn);
              _Visited[idn] = true;
            }
        }
      }
    }

int Thread_Num = 8; 

ATOMIC:
N: 10000  Time: 0.0001736
N: 90000  Time: 0.00136755
N: 1000000  Time: 0.015092
N: 9000000  Time: 0.131351
ATOMICFLAG:
N: 10000  Time: 0.0001246
N: 90000  Time: 0.0010323
N: 1000000  Time: 0.0114488
N: 9000000  Time: 0.0991202
SERIAL:
N: 10000  Time: 3.335e-05
N: 90000  Time: 0.00022855
N: 1000000  Time: 0.0025476
N: 9000000  Time: 0.0284417


int Thread_Num = 4;

ATOMIC:
N: 10000  Time: 0.0002362
N: 90000  Time: 0.00217695
N: 1000000  Time: 0.0216373
N: 9000000  Time: 0.182717
ATOMICFLAG:
N: 10000  Time: 0.000119
N: 90000  Time: 0.00095945
N: 1000000  Time: 0.0108009
N: 9000000  Time: 0.0980217
SERIAL:
N: 10000  Time: 2.505e-05
N: 90000  Time: 0.0002201
N: 1000000  Time: 0.0025764
N: 9000000  Time: 0.0229053


int Thread_Num = 2;

ATOMIC:
N: 10000  Time: 0.00019005
N: 90000  Time: 0.0015899
N: 1000000  Time: 0.0180353
N: 9000000  Time: 0.164307
ATOMICFLAG:
N: 10000  Time: 0.0002246
N: 90000  Time: 0.00174325
N: 1000000  Time: 0.0200202
N: 9000000  Time: 0.189641
SERIAL:
N: 10000  Time: 2.515e-05
N: 90000  Time: 0.000225
N: 1000000  Time: 0.0026235
N: 9000000  Time: 0.0218569


int Thread_Num = 16;

ATOMIC:
N: 10000  Time: 0.00026325
N: 90000  Time: 0.00139565
N: 1000000  Time: 0.0144894
N: 9000000  Time: 0.113346
ATOMICFLAG:
N: 10000  Time: 0.00010315
N: 90000  Time: 0.0011984
N: 1000000  Time: 0.00919795
N: 9000000  Time: 0.0751353
SERIAL:
N: 10000  Time: 3.71e-05
N: 90000  Time: 0.00026865
N: 1000000  Time: 0.002532
N: 9000000  Time: 0.021521


    for (int i = 0; i < _Mesh._Cells.size(); ++i) {
      id = _Mesh._Cells[i];
      if (_Mesh._Flag[id] == 1) {
        // get neighbours
        for (int j = 0; j < 8; j++) {
          idn = id + _Mesh._Nbr[j];
          if (_Mesh.has_Nbr(idn)) {
            if (!_Visited[idn]) {
              Cells.emplace_back(idn);
              _Visited[idn] = true;
            }
          }
        }
      }
    }

int Thread_Num = 16;

ATOMIC:
N: 10000  Time: 0.0001577
N: 90000  Time: 0.0024173
N: 1000000  Time: 0.0172942       0.0144894
N: 9000000  Time: 0.117548        0.113346
ATOMICFLAG:
N: 10000  Time: 0.00011285
N: 90000  Time: 0.0011764
N: 1000000  Time: 0.0122533        0.00919795
N: 9000000  Time: 0.0808442        0.0751353
SERIAL:
N: 10000  Time: 0.00017885
N: 90000  Time: 0.00075755
N: 1000000  Time: 0.0050762        0.002532
N: 9000000  Time: 0.0442161        0.021521


for (int i = 0; i < _Mesh._Cells.size(); ++i) {
      id = _Mesh._Cells[i];
      if (_Mesh._Flag[id] == 1) {
        // get neighbours
        for (int j = 0; j < 8; j++) {
          idn = id + _Mesh._Nbr[j];
          if (_Mesh.has_Nbr(idn)) {
            if (!_Visited[idn]) {
              Cells.emplace_back(idn);
              _Visited[idn] = true;
              _Mesh.flag[idn] = 1;
              _Mesh.flag1[idn] = 1;
              _Mesh.flag2[idn] = 1;
            }
          }
        }
      }
    }


ATOMIC:
N: 10000  Time: 0.0001737
N: 90000  Time: 0.0012624
N: 1000000  Time: 0.014245
N: 9000000  Time: 0.114989
ATOMICFLAG:
N: 10000  Time: 9.13e-05
N: 90000  Time: 0.00084645
N: 1000000  Time: 0.00931975
N: 9000000  Time: 0.0789166
SERIAL:
N: 10000  Time: 6.165e-05
N: 90000  Time: 0.0005486
N: 1000000  Time: 0.00412435
N: 9000000  Time: 0.0400364

the more complex the task is, the better performance the parallel version has.
